# איך עובד ייבוא מצגות (PPTX / PDF)

המערכת משתמשת בגישה של **"שכפול ויזואלי" (Visual Replication)** — כלומר, במקום לנסות לפרש את התוכן של המצגת (טקסט, פונטים, אנימציות), היא הופכת כל שקופית **לתמונה באיכות גבוהה** שנראית בדיוק כמו המקור.

---

## קבצי PDF — עיבוד בצד הלקוח (Client-Side)

קבצי PDF מעובדים **ישירות בדפדפן** של המשתמש בעזרת ספריית **pdfjs-dist** (הספרייה של Mozilla שמריצה PDFs):

1. הקובץ נקרא כ-`ArrayBuffer` בדפדפן.
2. **pdfjs** פותח את ה-PDF ועובר דף-דף.
3. כל דף **מרונדר ל-Canvas** של HTML5 — בגודל מקסימלי של 1920px רוחב (בקוד: עד 2560px לאיכות גבוהה), תוך שמירה על יחס הגובה-רוחב המקורי.
4. ה-Canvas מומר לתמונת **JPEG** (באיכות 0.85–0.92) בפורמט Data URL.
5. כל דף הופך ל**שקופית מסוג image** באפליקציה.

**למה בצד הלקוח?** כי pdfjs יכול לרנדר PDFs באופן מושלם בדפדפן, אז אין צורך בשרת. זה מהיר יותר ולא מעמיס על השרת.

**מיקום בקוד:** `src/lib/pdfToImages.ts` — `pdfFileToPngDataUrls()`.

---

## קבצי PPTX — עיבוד בצד השרת (Edge Function)

PPTX זה הסיפור המעניין יותר. קובץ PPTX הוא בעצם **קובץ ZIP** שמכיל בתוכו קבצי XML ותמונות. ה-Edge Function **convert-to-images** מפרק אותו כך:

### שלב 1 — פתיחת ה-ZIP

הקובץ נפתח בעזרת **JSZip**. בתוך ה-ZIP יש מבנה תיקיות סטנדרטי:

- `ppt/presentation.xml` — הגדרות המצגת (כולל גודל השקופיות ב-EMU)
- `ppt/slides/slide1.xml`, `slide2.xml`... — כל שקופית
- `ppt/theme/theme1.xml` — ערכת הצבעים
- `ppt/media/` — כל התמונות שמוטמעות במצגת
- `ppt/slides/_rels/` — קובצי relationships שמקשרים בין אלמנטים לתמונות

### שלב 2 — חילוץ הנתונים

- **צבעי ערכת נושא** — נקראים מ-`theme1.xml`, כולל dk1, lt1, accent1–6 וכו'.
- **תמונות מוטמעות** — כל קובץ מ-`ppt/media/` מומר ל-base64 Data URL.
- **גודל השקופית** — נקרא מ-`presentation.xml` ביחידות **EMU** (English Metric Units; 914,400 EMU = אינץ' אחד).

### שלב 3 — פרסור כל שקופית

כל `slide.xml` מפורסר ומחולצים ממנו:

- **רקע** — צבע אחיד או גרדיאנט
- **אלמנטי טקסט** (`p:sp`) — מיקום (x,y), גודל, פונט, צבע, bold/italic, יישור, bullets
- **תמונות** (`p:pic`) — מיקום וגודל + reference ID שמקשר לקובץ ב-`media`
- **צורות** — מלבנים, קווים וכו' עם צבע מילוי וקו מתאר

כל המיקומים מומרים מ-EMU לפיקסלים על **קנבס של 1920×1080** — בדיוק כמו גודל השקופיות באפליקציה.

### שלב 4 — רינדור ל-SVG

כל שקופית מרונדרת ל**קובץ SVG** שמכיל:

- רקע כ-`<rect>`
- תמונות כ-`<image>` עם ה-base64 מוטמע
- טקסט כ-`<text>` עם מיקום, צבע וגודל פונט מדויקים
- צורות כ-`<rect>` עם fill ו-stroke

ה-SVG נשלח ללקוח כ-Data URL.

**מיקום בקוד:** `supabase/functions/convert-to-images/index.ts` — `parsePptxToImages()`.

### שלב 5 — אופטימיזציה בצד הלקוח

ה-SVGs חוזרים לדפדפן, ושם הם עוברים המרה:

1. SVGs מומרים ל-**PNG** בעזרת `svgToPng()` (רינדור ב-Canvas).
2. תמונות מוקטנות ל-**1920px** רוחב מקסימלי (קנבס 1920×1080).
3. מומרות ל-**JPEG** באיכות 0.85 לחיסכון בנפח ויציבות.

**מיקום בקוד:** `src/components/editor/ImportPresentationDialog.tsx` (לולאת PPTX), `src/lib/imageUtils.ts` — `svgToPng()`, `resizeImage()`.

---

## שלב אחרון — יצירת שקופיות באפליקציה

- המשתמש רואה **תצוגה מקדימה** ויכול לבחור אילו שקופיות לייבא.
- כל תמונה (מ-PDF או PPTX) הופכת ל**שקופית מסוג image**.
- כל שקופית מאוחסנת עם ה-Data URL של התמונה (או עם URL אם הועלתה ל-Storage).
- שקופיות מיובאות **מרונדרות בבידוד** — בלי תלות בעיצוב גלובלי; כל שקף הוא תמונה עצמאית.

---

## סיכום

| סוג קובץ | איפה מעובד | פלט ביניים | פלט סופי |
|----------|------------|-------------|----------|
| **PDF**  | דפדפן (pdfjs) | Canvas → JPEG Data URL | שקופית image |
| **PPTX** | שרת (Edge Function) → דפדפן | ZIP → XML → SVG → (Client) PNG/JPEG | שקופית image |

גישה זו מבטיחה שהמראה החזותי של המצגת המקורית נשמר, בלי תלות בפונטים או באנימציות בשרת או בלקוח.
